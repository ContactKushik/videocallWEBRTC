// WebRTC and Signaling Setup
const socket = io(); // Initialize WebSocket connection
let localStream; // Local media stream
let remoteStream; // Remote media stream
let peerConnection; // RTCPeerConnection instance

// STUN server for NAT traversal
const rtcConfig = {
  iceServers: [{ urls: "stun:stun.l.google.com:19302" }], // Using Google's public STUN server
};

/**
 * Initialize WebRTC setup: get local media, set up signaling, and initiate the offer.
 */
const initialize = async () => {
  console.log("Initializing WebRTC connection...");

  // Step 1: Set up signaling event handlers
  setupSignalingHandlers();

  // Step 2: Get access to local media (audio/video) and display it
  await setupLocalStream();

  // Step 3: Initiate the connection by creating and sending an offer
  await initiateOffer();
};

/**
 * Set up signaling handlers for WebSocket messages.
 */
const setupSignalingHandlers = () => {
  // Listening for signaling messages from the server
  socket.on("signalingMessage", handleSignalingMessage);
};

/**
 * Get the local media stream and display it on the local video element.
 */
const setupLocalStream = async () => {
  try {
    // Request access to the user's microphone and camera
    localStream = await navigator.mediaDevices.getUserMedia({
      audio: true,
      video: true,
    });

    // Assign the local stream to the local video element
    document.querySelector("#localVideo").srcObject = localStream;
  } catch (error) {
    console.error("Error accessing local media:", error);
  }
};

/**
 * Create and configure the RTCPeerConnection instance.
 */
const createPeerConnection = () => {
  // Initialize a new RTCPeerConnection instance with the specified configuration
  peerConnection = new RTCPeerConnection(rtcConfig);

  // Step 4: Prepare a stream to display incoming remote media
  remoteStream = new MediaStream();
  document.querySelector("#remoteVideo").srcObject = remoteStream;

  // Step 5: Add all tracks (audio and video) from the local stream to the connection
  localStream
    .getTracks()
    .forEach((track) => peerConnection.addTrack(track, localStream));

  // Step 6: Handle incoming remote tracks and add them to the remote stream
  peerConnection.ontrack = (event) => {
    event.streams[0]
      .getTracks()
      .forEach((track) => remoteStream.addTrack(track));
  };

  // Step 7: Handle ICE candidates generated by the local connection
  peerConnection.onicecandidate = (event) => {
    if (event.candidate) {
      // Send the ICE candidate to the remote peer through the signaling server
      sendSignalingMessage({ type: "candidate", candidate: event.candidate });
    }
  };
};

/**
 * Initiate the WebRTC connection by creating and sending an offer.
 */
const initiateOffer = async () => {
  // Step 8: Create a new RTCPeerConnection instance
  createPeerConnection();

  try {
    // Step 9: Generate an SDP offer
    const offer = await peerConnection.createOffer();

    // Step 10: Set the offer as the local description
    await peerConnection.setLocalDescription(offer);

    // Step 11: Send the offer to the remote peer via the signaling server
    sendSignalingMessage({ type: "offer", offer });
  } catch (error) {
    console.error("Error creating offer:", error);
  }
};

/**
 * Handle incoming signaling messages.
 * @param {string} message - JSON stringified signaling message.
 */
const handleSignalingMessage = async (message) => {
  const { type, offer, answer, candidate } = JSON.parse(message);

  // Step 12: Act based on the type of signaling message received
  switch (type) {
    case "offer":
      await handleOffer(offer); // Handle an incoming offer from a remote peer
      break;
    case "answer":
      await handleAnswer(answer); // Handle an answer to our offer
      break;
    case "candidate":
      await addIceCandidate(candidate); // Handle an ICE candidate
      break;
    default:
      console.warn("Unknown signaling message type:", type);
  }
};

/**
 * Handle an incoming offer, create an answer, and send it back.
 * @param {RTCSessionDescriptionInit} offer - The SDP offer.
 */
const handleOffer = async (offer) => {
  // Step 13: Create a new RTCPeerConnection instance
  createPeerConnection();

  try {
    // Step 14: Set the remote peer's offer as the remote description
    await peerConnection.setRemoteDescription(offer);

    // Step 15: Generate an SDP answer
    const answer = await peerConnection.createAnswer();

    // Step 16: Set the answer as the local description
    await peerConnection.setLocalDescription(answer);

    // Step 17: Send the answer back to the remote peer via the signaling server
    sendSignalingMessage({ type: "answer", answer });
  } catch (error) {
    console.error("Error handling offer:", error);
  }
};

/**
 * Handle an incoming answer and finalize the WebRTC connection.
 * @param {RTCSessionDescriptionInit} answer - The SDP answer.
 */
const handleAnswer = async (answer) => {
  try {
    // Step 18: Set the remote peer's answer as the remote description
    await peerConnection.setRemoteDescription(answer);
  } catch (error) {
    console.error("Error handling answer:", error);
  }
};

/**
 * Add an ICE candidate to the RTCPeerConnection.
 * @param {RTCIceCandidateInit} candidate - The ICE candidate.
 */
const addIceCandidate = async (candidate) => {
  try {
    // Step 19: Add the ICE candidate to the connection
    await peerConnection.addIceCandidate(candidate);
  } catch (error) {
    console.error("Error adding ICE candidate:", error);
  }
};

/**
 * Send a signaling message through the WebSocket.
 * @param {Object} message - The signaling message to send.
 */
const sendSignalingMessage = (message) => {
  // Step 20: Emit the signaling message to the server
  socket.emit("signalingMessage", JSON.stringify(message));
};

// Start the WebRTC setup
initialize(); // Entry point of the program
